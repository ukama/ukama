/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Copyright (c) 2023-present, Ukama Inc.
 */

package server

import (
	"context"
	"strings"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/ukama/ukama/systems/common/msgbus"
	"github.com/ukama/ukama/systems/node/configurator/pkg/db"

	log "github.com/sirupsen/logrus"
	epb "github.com/ukama/ukama/systems/common/pb/gen/events"
	eCfgPb "github.com/ukama/ukama/systems/common/pb/gen/ukama"
)

type ConfiguratorEventServer struct {
	s       *ConfiguratorServer
	orgName string
	epb.UnimplementedEventNotificationServiceServer
}

func NewConfiguratorEventServer(orgName string, s *ConfiguratorServer) *ConfiguratorEventServer {
	return &ConfiguratorEventServer{
		s:       s,
		orgName: orgName,
	}
}

func (n *ConfiguratorEventServer) EventNotification(ctx context.Context, e *epb.Event) (*epb.EventResponse, error) {
	log.Infof("Received a message with Routing key %s and Message %+v", e.RoutingKey, e.Msg)
	switch e.RoutingKey {
	case msgbus.PrepareRoute(n.orgName, "event.cloud.local.{{ .Org}}.registry.node.node.create"):
		msg, err := n.unmarshalRegistryNodeAddEvent(e.Msg)
		if err != nil {
			return nil, err
		}

		err = n.handleRegistryNodeAddEvent(e.RoutingKey, msg)
		if err != nil {
			return nil, err
		}

	case msgbus.PrepareRoute(n.orgName, "event.node.local.{{ .Org}}.messaging.mesh.config.create"):
		msg, err := n.unmarshalNodeConfigUpdateEvent(e.Msg)
		if err != nil {
			return nil, err
		}

		err = n.handleNodeConfigUpdateEvent(e.RoutingKey, msg)
		if err != nil {
			return nil, err
		}
	default:
		log.Errorf("No handler routing key %s", e.RoutingKey)
	}

	return &epb.EventResponse{}, nil
}

func (n *ConfiguratorEventServer) unmarshalRegistryNodeAddEvent(msg *anypb.Any) (*epb.NodeCreatedEvent, error) {
	p := &epb.NodeCreatedEvent{}
	err := anypb.UnmarshalTo(msg, p, proto.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true})
	if err != nil {
		log.Errorf("Failed to Unmarshal NodeOnline  message with : %+v. Error %s.", msg, err.Error())
		return nil, err
	}
	return p, nil
}

// so, commenting for compiling.
func (n *ConfiguratorEventServer) handleRegistryNodeAddEvent(key string, msg *epb.NodeCreatedEvent) error {
	log.Infof("Keys %s and Proto is: %+v", key, msg)

	//TBU
	/* This will add node to configuration db
	Two ways node can be added to configurator db
	 First event should be generated by node service in registry after successful addition
	 Second may be on first successful health update
	 in second option we would know what version this node is on and all that
	*/
	err := n.s.configRepo.Add(strings.ToLower(msg.NodeId))
	if err != nil {
		log.Errorf("Error adding node %s to configuration repo.Error: %+v", msg.NodeId, err)
		return err
	}

	/* Getting latest config */
	cfg, err := n.s.commitRepo.GetLatest()
	if err != nil {
		log.Errorf("Failed to get latest config for node %s. Error: %+v", msg.NodeId, err)
		return err
	}

	/* Pushing latest available config */
	err = n.s.configStore.HandleConfigCommitReqForNode(context.Background(), cfg.Hash, msg.NodeId)
	if err != nil {
		log.Errorf("Error updating node %s to config %s. Error: %+v", msg.NodeId, cfg.Hash, err)
		return err
	}

	return nil
}

/* To Be tested on integration */
func (n *ConfiguratorEventServer) unmarshalNodeConfigUpdateEvent(msg *anypb.Any) (*eCfgPb.NodeConfigUpdateEvent, error) {
	p := &eCfgPb.NodeConfigUpdateEvent{}
	err := anypb.UnmarshalTo(msg, p, proto.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true})
	if err != nil {
		log.Errorf("Failed to Unmarshal NodeConfigUpdate message with : %+v. Error %s.", msg, err.Error())
		return nil, err
	}
	return p, nil
}

// so, commenting for compiling.
func (n *ConfiguratorEventServer) handleNodeConfigUpdateEvent(key string, msg *eCfgPb.NodeConfigUpdateEvent) error {
	log.Infof("Keys %s and Proto is: %+v", key, msg)

	cfg, err := n.s.configRepo.Get(strings.ToLower(msg.NodeId))
	if err != nil {
		log.Errorf("Error reading node %s from configuration repo.Error: %+v", msg.NodeId, err)
		return err
	}

	c, err := n.s.commitRepo.Get(msg.GetCommit())
	if err != nil {
		log.Errorf("Error reading commit %s from commit repo.Error: %+v", msg.Commit, err)
		return err
	}

	state := db.CommitState(uint8(msg.GetStatus()))
	if state == db.Success || state == db.Rollback || state == db.Default {
		cfg.Commit = *c
		err = n.s.configRepo.UpdateCurrentCommit(*cfg, &state)
		if err != nil {
			log.Errorf("Error updating node %s commit configuration repo.Error: %+v", msg.NodeId, err)
			return err
		}

	} else if state == db.Failed {
		err = n.s.configRepo.UpdateLastCommit(*cfg, &state)
		if err != nil {
			log.Errorf("Error adding node %s last commit configuration repo.Error: %+v", msg.NodeId, err)
			return err
		}
	} else {
		log.Warningf("Unwanted config states: %v", msg)
		return nil
	}

	return nil
}
